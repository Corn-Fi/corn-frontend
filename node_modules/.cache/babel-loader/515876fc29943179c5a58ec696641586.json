{"ast":null,"code":"import React from \"react\";\nimport { ethers } from \"ethers\";\nexport const getUserFarmData = async (signer, masterchefContract, pLength, poolInfo) => {\n  const accountAddress = await signer.getAddress();\n  console.log(pLength);\n  const userPoolDataPromises = [];\n\n  for (let pid = 0; pid < pLength; pid++) {\n    const poolData = masterchefContract.pendingCob(pid, accountAddress);\n    userPoolDataPromises.push(poolData);\n  }\n\n  ;\n  Promise.all(userPoolDataPromises).then(values => {\n    const dataPack = [];\n    const yurt = values.map((value, index) => {\n      const pending = ethers.utils.formatUnits(value, \"ether\");\n      const pool = poolInfo[index];\n      const lpToken = pool.lpToken;\n      const allocationPoints = pool.allocPoint;\n      const accCobPerShare = pool.accCobPerShare;\n      const depositFee = pool.depositFeeBP;\n      const dat = {\n        pendingReward: pending,\n        poolInformation: {\n          depositTokenAddress: lpToken,\n          allocation: allocationPoints,\n          rewardPerShare: accCobPerShare,\n          fee: depositFee\n        }\n      };\n      dataPack.push(dat); // return {\n      //     pendingReward: pending, \n      //     poolInformation: {\n      //         depositTokenAddress: lpToken,\n      //         allocation: allocationPoints,\n      //         rewardPerShare: accCobPerShare,\n      //         fee: depositFee\n      //     }};\n    });\n    console.log(typeof dataPack);\n    return dataPack;\n  });\n};\nexport const getPoolLength = async _masterchef => {\n  _masterchef.poolLength().then(res => {\n    return res;\n  });\n};\nexport const mapPendingToOriginalData = async (newData, oldData, _masterchef) => {\n  const poolLength = getPoolLength(_masterchef);\n  const staticPoolLength = oldData.length;\n\n  if (poolLength == staticPoolLength) {\n    const recycledData = newData.map((value, index) => {\n      const pending = value.pendingReward;\n      return {\n        pendingCob: pending,\n        ...oldData\n      };\n    });\n  } else {\n    console.log(`Devie needs to update static pool folder.  Your fetched pool length is ${poolLength} but your static pool length is ${staticPoolLength}`);\n    return oldData;\n  }\n};","map":{"version":3,"sources":["/Users/nolanterry/Desktop/CORNLIMITFRONTEND/cornfrontend/src/utils/fetchUserData.js"],"names":["React","ethers","getUserFarmData","signer","masterchefContract","pLength","poolInfo","accountAddress","getAddress","console","log","userPoolDataPromises","pid","poolData","pendingCob","push","Promise","all","then","values","dataPack","yurt","map","value","index","pending","utils","formatUnits","pool","lpToken","allocationPoints","allocPoint","accCobPerShare","depositFee","depositFeeBP","dat","pendingReward","poolInformation","depositTokenAddress","allocation","rewardPerShare","fee","getPoolLength","_masterchef","poolLength","res","mapPendingToOriginalData","newData","oldData","staticPoolLength","length","recycledData"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAAQC,MAAR,QAAqB,QAArB;AAEA,OAAO,MAAMC,eAAe,GAAG,OAAOC,MAAP,EAAeC,kBAAf,EAAmCC,OAAnC,EAA4CC,QAA5C,KAAyD;AAGpF,QAAMC,cAAc,GAAG,MAAMJ,MAAM,CAACK,UAAP,EAA7B;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYL,OAAZ;AAEA,QAAMM,oBAAoB,GAAG,EAA7B;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGP,OAAxB,EAAiCO,GAAG,EAApC,EAAwC;AACpC,UAAMC,QAAQ,GAAGT,kBAAkB,CAACU,UAAnB,CAA8BF,GAA9B,EAAmCL,cAAnC,CAAjB;AACAI,IAAAA,oBAAoB,CAACI,IAArB,CAA0BF,QAA1B;AACH;;AAAA;AAEDG,EAAAA,OAAO,CAACC,GAAR,CAAYN,oBAAZ,EACCO,IADD,CACMC,MAAM,IAAI;AACZ,UAAMC,QAAQ,GAAG,EAAjB;AACA,UAAMC,IAAI,GAAGF,MAAM,CAACG,GAAP,CAAW,CAACC,KAAD,EAAQC,KAAR,KAAkB;AAEtC,YAAMC,OAAO,GAAGxB,MAAM,CAACyB,KAAP,CAAaC,WAAb,CAAyBJ,KAAzB,EAAgC,OAAhC,CAAhB;AAEA,YAAMK,IAAI,GAAGtB,QAAQ,CAACkB,KAAD,CAArB;AACA,YAAMK,OAAO,GAAGD,IAAI,CAACC,OAArB;AACA,YAAMC,gBAAgB,GAAGF,IAAI,CAACG,UAA9B;AACA,YAAMC,cAAc,GAAGJ,IAAI,CAACI,cAA5B;AACA,YAAMC,UAAU,GAAGL,IAAI,CAACM,YAAxB;AAEA,YAAMC,GAAG,GAAG;AACRC,QAAAA,aAAa,EAAEX,OADP;AAERY,QAAAA,eAAe,EAAE;AACbC,UAAAA,mBAAmB,EAAET,OADR;AAEbU,UAAAA,UAAU,EAAET,gBAFC;AAGbU,UAAAA,cAAc,EAAER,cAHH;AAIbS,UAAAA,GAAG,EAAER;AAJQ;AAFT,OAAZ;AASAb,MAAAA,QAAQ,CAACL,IAAT,CAAcoB,GAAd,EAnBsC,CAqBtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,KA7BY,CAAb;AA8BA1B,IAAAA,OAAO,CAACC,GAAR,CAAY,OAAOU,QAAnB;AACA,WAAOA,QAAP;AACH,GAnCD;AAqCH,CAjDM;AAmDP,OAAO,MAAMsB,aAAa,GAAG,MAAOC,WAAP,IAAuB;AAChDA,EAAAA,WAAW,CAACC,UAAZ,GAAyB1B,IAAzB,CAA+B2B,GAAG,IAAI;AAClC,WAAOA,GAAP;AACH,GAFD;AAGH,CAJM;AAMP,OAAO,MAAMC,wBAAwB,GAAG,OAAOC,OAAP,EAAgBC,OAAhB,EAAyBL,WAAzB,KAAyC;AAC7E,QAAMC,UAAU,GAAGF,aAAa,CAACC,WAAD,CAAhC;AACA,QAAMM,gBAAgB,GAAGD,OAAO,CAACE,MAAjC;;AACA,MAAIN,UAAU,IAAIK,gBAAlB,EAAoC;AAEhC,UAAME,YAAY,GAAGJ,OAAO,CAACzB,GAAR,CAAY,CAACC,KAAD,EAAQC,KAAR,KAAkB;AAC/C,YAAMC,OAAO,GAAGF,KAAK,CAACa,aAAtB;AACA,aAAO;AACHtB,QAAAA,UAAU,EAAEW,OADT;AAEH,WAAGuB;AAFA,OAAP;AAIH,KANoB,CAArB;AAQH,GAVD,MAUO;AAEHvC,IAAAA,OAAO,CAACC,GAAR,CAAa,0EAAyEkC,UAAW,mCAAkCK,gBAAiB,EAApJ;AACA,WAAOD,OAAP;AAEH;AAGJ,CArBM","sourcesContent":["import React from \"react\";\nimport {ethers} from \"ethers\";\n\nexport const getUserFarmData = async (signer, masterchefContract, pLength, poolInfo) => {\n\n\n    const accountAddress = await signer.getAddress();\n    console.log(pLength)\n\n    const userPoolDataPromises = [];\n    for (let pid = 0; pid < pLength; pid++) {\n        const poolData = masterchefContract.pendingCob(pid, accountAddress);\n        userPoolDataPromises.push(poolData);\n    };\n\n    Promise.all(userPoolDataPromises)\n    .then(values => {\n        const dataPack = []\n        const yurt = values.map((value, index) => {\n\n            const pending = ethers.utils.formatUnits(value, \"ether\");\n\n            const pool = poolInfo[index];\n            const lpToken = pool.lpToken;\n            const allocationPoints = pool.allocPoint;\n            const accCobPerShare = pool.accCobPerShare;\n            const depositFee = pool.depositFeeBP;\n\n            const dat = {\n                pendingReward: pending, \n                poolInformation: {\n                    depositTokenAddress: lpToken,\n                    allocation: allocationPoints,\n                    rewardPerShare: accCobPerShare,\n                    fee: depositFee\n                }}\n            \n            dataPack.push(dat)\n\n            // return {\n            //     pendingReward: pending, \n            //     poolInformation: {\n            //         depositTokenAddress: lpToken,\n            //         allocation: allocationPoints,\n            //         rewardPerShare: accCobPerShare,\n            //         fee: depositFee\n            //     }};\n        })\n        console.log(typeof(dataPack))\n        return dataPack\n    })\n\n}\n\nexport const getPoolLength = async (_masterchef) => {\n    _masterchef.poolLength().then( res => {\n        return res\n    }); \n}\n\nexport const mapPendingToOriginalData = async (newData, oldData, _masterchef) => {\n    const poolLength = getPoolLength(_masterchef);\n    const staticPoolLength = oldData.length;\n    if (poolLength == staticPoolLength) {\n\n        const recycledData = newData.map((value, index) => {\n            const pending = value.pendingReward;\n            return {\n                pendingCob: pending,\n                ...oldData\n            };\n        });\n\n    } else {\n\n        console.log(`Devie needs to update static pool folder.  Your fetched pool length is ${poolLength} but your static pool length is ${staticPoolLength}`);\n        return oldData;\n\n    }\n\n\n}"]},"metadata":{},"sourceType":"module"}