{"ast":null,"code":"import React from \"react\";\nimport { ethers } from \"ethers\";\nimport { writeContract } from \"./nft\";\n\nconst getPoolInfo = async (masterchef, poolLength) => {\n  const pLength = poolLength;\n  const poolInfo = [];\n\n  for (let index = 0; index < pLength; index++) {\n    const data = await masterchef.poolInfo(index);\n    poolInfo.push(data);\n  }\n\n  return poolInfo;\n}; // works\n\n\nconst checkUserApprovedPool = async (tokendeposit, account, signer, masterchef, erc20abi) => {\n  // const erc20 = await fetchContract(tokendeposit, erc20abi, signer);\n  const allowance = await erc20.allowance(account, masterchef.address);\n  const formattedAllowance = ethers.utils.formatUnits(allowance, \"ether\");\n  console.log(formattedAllowance);\n\n  if (formattedAllowance !== \"0.0\") {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nexport const fetchUserPoolData = async (_masterChef, _library, _account, poolLength) => {\n  const pLength = poolLength;\n  const accountAddress = _account;\n  const poolInfo = await getPoolInfo(_masterChef, poolLength);\n  const userPoolDataPromises = [];\n\n  for (let pid = 0; pid < pLength; pid++) {\n    const poolData = _masterChef.pendingCob(pid, accountAddress);\n\n    userPoolDataPromises.push(poolData);\n  }\n\n  ;\n  const dataPack = Promise.all(userPoolDataPromises).then(values => {\n    const data = values.map((value, index) => {\n      const pending = ethers.utils.formatUnits(value, \"ether\");\n      const pool = poolInfo[index];\n      const lpToken = pool.lpToken;\n      const allocationPoints = ethers.utils.formatUnits(pool.allocPoint, \"wei\");\n      const accCobPerShare = ethers.utils.formatUnits(pool.accCobPerShare, \"ether\");\n      const depositFee = pool.depositFeeBP; // const userApproved = fetchPoolAllowance() // fix this dummy\n      // pools, _signer, _account, _masterchef\n\n      return {\n        pendingReward: pending,\n        poolInformation: {\n          depositTokenAddress: lpToken,\n          allocation: allocationPoints,\n          rewardPerShare: accCobPerShare,\n          fee: depositFee\n        }\n      };\n    });\n    return data;\n  });\n  return dataPack;\n};\nexport const getPoolLength = async _masterchef => {\n  _masterchef.poolLength().then(res => {\n    return res;\n  });\n};\nexport const mapPendingToOriginalData = (newData, oldData, _masterchef, poolLength) => {\n  const staticPoolLength = oldData.length;\n\n  if (poolLength == staticPoolLength) {\n    const recycledData = newData.map((value, index) => {\n      const pending = value.pendingReward;\n      return {\n        pendingCob: pending,\n        ...oldData[index]\n      };\n    });\n    return recycledData;\n  } else {\n    console.log(`Devie needs to update static pool folder.  Your fetched pool length is ${poolLength} but your static pool length is ${staticPoolLength}`);\n    return oldData;\n  }\n};\nexport const getPoolBalance = async (poolData, _active, signer, account, abi, plength) => {\n  const balances = poolData.map(async (value, index) => {\n    const address = value.tokenStakeAddress;\n    const erc20 = await writeContract(_active, signer, account, address, abi);\n    const masterChefAddress = \"0xC71EbC899BCC111F39B2715B5d2D397E671B5bd2\";\n    const balance = await erc20.balanceOf(masterChefAddress);\n    const stringbal = ethers.utils.formatUnits(balance, \"ether\");\n    return stringbal;\n  });\n  const results = await Promise.all(balances);\n  return results;\n};","map":{"version":3,"sources":["/Users/nolanterry/Desktop/CORNLIMITFRONTEND/cornfrontend/src/utils/fetchUserData.js"],"names":["React","ethers","writeContract","getPoolInfo","masterchef","poolLength","pLength","poolInfo","index","data","push","checkUserApprovedPool","tokendeposit","account","signer","erc20abi","allowance","erc20","address","formattedAllowance","utils","formatUnits","console","log","fetchUserPoolData","_masterChef","_library","_account","accountAddress","userPoolDataPromises","pid","poolData","pendingCob","dataPack","Promise","all","then","values","map","value","pending","pool","lpToken","allocationPoints","allocPoint","accCobPerShare","depositFee","depositFeeBP","pendingReward","poolInformation","depositTokenAddress","allocation","rewardPerShare","fee","getPoolLength","_masterchef","res","mapPendingToOriginalData","newData","oldData","staticPoolLength","length","recycledData","getPoolBalance","_active","abi","plength","balances","tokenStakeAddress","masterChefAddress","balance","balanceOf","stringbal","results"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAAQC,MAAR,QAAqB,QAArB;AACA,SAAQC,aAAR,QAA4B,OAA5B;;AAEA,MAAMC,WAAW,GAAG,OAAOC,UAAP,EAAmBC,UAAnB,KAAkC;AAClD,QAAMC,OAAO,GAAGD,UAAhB;AAEA,QAAME,QAAQ,GAAG,EAAjB;;AACA,OAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,OAA5B,EAAqCE,KAAK,EAA1C,EAA8C;AAC1C,UAAMC,IAAI,GAAG,MAAML,UAAU,CAACG,QAAX,CAAoBC,KAApB,CAAnB;AACAD,IAAAA,QAAQ,CAACG,IAAT,CAAcD,IAAd;AAEH;;AAED,SAAOF,QAAP;AACH,CAXD,C,CAWE;;;AAEF,MAAMI,qBAAqB,GAAG,OAAOC,YAAP,EAAqBC,OAArB,EAA8BC,MAA9B,EAAsCV,UAAtC,EAAkDW,QAAlD,KAA+D;AACzF;AACA,QAAMC,SAAS,GAAG,MAAMC,KAAK,CAACD,SAAN,CAAgBH,OAAhB,EAAyBT,UAAU,CAACc,OAApC,CAAxB;AACA,QAAMC,kBAAkB,GAAGlB,MAAM,CAACmB,KAAP,CAAaC,WAAb,CAAyBL,SAAzB,EAAoC,OAApC,CAA3B;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAYJ,kBAAZ;;AACA,MAAIA,kBAAkB,KAAK,KAA3B,EAAkC;AAC9B,WAAO,IAAP;AACH,GAFD,MAEO;AACH,WAAO,KAAP;AACH;AACJ,CAVD;;AAYA,OAAO,MAAMK,iBAAiB,GAAG,OAAOC,WAAP,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwCtB,UAAxC,KAAuD;AAEpF,QAAMC,OAAO,GAAGD,UAAhB;AACA,QAAMuB,cAAc,GAAGD,QAAvB;AACA,QAAMpB,QAAQ,GAAG,MAAMJ,WAAW,CAACsB,WAAD,EAAcpB,UAAd,CAAlC;AAGA,QAAMwB,oBAAoB,GAAG,EAA7B;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGxB,OAAxB,EAAiCwB,GAAG,EAApC,EAAwC;AACpC,UAAMC,QAAQ,GAAGN,WAAW,CAACO,UAAZ,CAAuBF,GAAvB,EAA4BF,cAA5B,CAAjB;;AACAC,IAAAA,oBAAoB,CAACnB,IAArB,CAA0BqB,QAA1B;AACH;;AAAA;AAED,QAAME,QAAQ,GAAGC,OAAO,CAACC,GAAR,CAAYN,oBAAZ,EAChBO,IADgB,CACXC,MAAM,IAAI;AACZ,UAAM5B,IAAI,GAAG4B,MAAM,CAACC,GAAP,CAAW,CAACC,KAAD,EAAQ/B,KAAR,KAAkB;AACtC,YAAMgC,OAAO,GAAGvC,MAAM,CAACmB,KAAP,CAAaC,WAAb,CAAyBkB,KAAzB,EAAgC,OAAhC,CAAhB;AAEA,YAAME,IAAI,GAAGlC,QAAQ,CAACC,KAAD,CAArB;AACA,YAAMkC,OAAO,GAAGD,IAAI,CAACC,OAArB;AACA,YAAMC,gBAAgB,GAAG1C,MAAM,CAACmB,KAAP,CAAaC,WAAb,CAAyBoB,IAAI,CAACG,UAA9B,EAA0C,KAA1C,CAAzB;AACA,YAAMC,cAAc,GAAG5C,MAAM,CAACmB,KAAP,CAAaC,WAAb,CAAyBoB,IAAI,CAACI,cAA9B,EAA8C,OAA9C,CAAvB;AACA,YAAMC,UAAU,GAAGL,IAAI,CAACM,YAAxB,CAPsC,CAQtC;AACA;;AAEA,aAAO;AACHC,QAAAA,aAAa,EAAER,OADZ;AAEHS,QAAAA,eAAe,EAAE;AACbC,UAAAA,mBAAmB,EAAER,OADR;AAEbS,UAAAA,UAAU,EAAER,gBAFC;AAGbS,UAAAA,cAAc,EAAEP,cAHH;AAIbQ,UAAAA,GAAG,EAAEP;AAJQ;AAFd,OAAP;AAQH,KAnBY,CAAb;AAoBA,WAAOrC,IAAP;AACH,GAvBgB,CAAjB;AAwBA,SAAOwB,QAAP;AACH,CAtCM;AAwCP,OAAO,MAAMqB,aAAa,GAAG,MAAOC,WAAP,IAAuB;AAChDA,EAAAA,WAAW,CAAClD,UAAZ,GAAyB+B,IAAzB,CAA+BoB,GAAG,IAAI;AAClC,WAAOA,GAAP;AACH,GAFD;AAGH,CAJM;AAMP,OAAO,MAAMC,wBAAwB,GAAG,CAACC,OAAD,EAAUC,OAAV,EAAmBJ,WAAnB,EAAgClD,UAAhC,KAA+C;AACnF,QAAMuD,gBAAgB,GAAGD,OAAO,CAACE,MAAjC;;AACA,MAAIxD,UAAU,IAAIuD,gBAAlB,EAAoC;AAChC,UAAME,YAAY,GAAGJ,OAAO,CAACpB,GAAR,CAAY,CAACC,KAAD,EAAQ/B,KAAR,KAAkB;AAC/C,YAAMgC,OAAO,GAAGD,KAAK,CAACS,aAAtB;AACA,aAAO;AACHhB,QAAAA,UAAU,EAAEQ,OADT;AAEH,WAAGmB,OAAO,CAACnD,KAAD;AAFP,OAAP;AAIH,KANoB,CAArB;AAQA,WAAOsD,YAAP;AAEH,GAXD,MAWO;AAEHxC,IAAAA,OAAO,CAACC,GAAR,CAAa,0EAAyElB,UAAW,mCAAkCuD,gBAAiB,EAApJ;AACA,WAAOD,OAAP;AAEH;AAGJ,CArBM;AAuBP,OAAO,MAAMI,cAAc,GAAG,OAAOhC,QAAP,EAAiBiC,OAAjB,EAA0BlD,MAA1B,EAAkCD,OAAlC,EAA2CoD,GAA3C,EAAgDC,OAAhD,KAA4D;AAGtF,QAAMC,QAAQ,GAAGpC,QAAQ,CAACO,GAAT,CAAc,OAAOC,KAAP,EAAc/B,KAAd,KAAwB;AACnD,UAAMU,OAAO,GAAGqB,KAAK,CAAC6B,iBAAtB;AACA,UAAMnD,KAAK,GAAI,MAAMf,aAAa,CAAC8D,OAAD,EAAUlD,MAAV,EAAkBD,OAAlB,EAA2BK,OAA3B,EAAoC+C,GAApC,CAAlC;AACA,UAAMI,iBAAiB,GAAG,4CAA1B;AACA,UAAMC,OAAO,GAAI,MAAMrD,KAAK,CAACsD,SAAN,CAAgBF,iBAAhB,CAAvB;AACA,UAAMG,SAAS,GAAGvE,MAAM,CAACmB,KAAP,CAAaC,WAAb,CAAyBiD,OAAzB,EAAkC,OAAlC,CAAlB;AACA,WAAOE,SAAP;AACH,GAPgB,CAAjB;AASA,QAAMC,OAAO,GAAG,MAAMvC,OAAO,CAACC,GAAR,CAAYgC,QAAZ,CAAtB;AACA,SAAOM,OAAP;AACH,CAdM","sourcesContent":["import React from \"react\";\nimport {ethers} from \"ethers\";\nimport {writeContract} from \"./nft\"\n\nconst getPoolInfo = async (masterchef, poolLength) => {\n    const pLength = poolLength\n\n    const poolInfo = [];\n    for (let index = 0; index < pLength; index++) {\n        const data = await masterchef.poolInfo(index);\n        poolInfo.push(data);\n        \n    }\n\n    return poolInfo;\n} // works\n\nconst checkUserApprovedPool = async (tokendeposit, account, signer, masterchef, erc20abi) => {\n    // const erc20 = await fetchContract(tokendeposit, erc20abi, signer);\n    const allowance = await erc20.allowance(account, masterchef.address);\n    const formattedAllowance = ethers.utils.formatUnits(allowance, \"ether\");\n    console.log(formattedAllowance)\n    if (formattedAllowance !== \"0.0\") {\n        return true\n    } else {\n        return false\n    }\n}\n\nexport const fetchUserPoolData = async (_masterChef, _library, _account, poolLength) => {\n\n    const pLength = poolLength\n    const accountAddress = _account;\n    const poolInfo = await getPoolInfo(_masterChef, poolLength);\n\n\n    const userPoolDataPromises = [];\n    for (let pid = 0; pid < pLength; pid++) {\n        const poolData = _masterChef.pendingCob(pid, accountAddress);\n        userPoolDataPromises.push(poolData);\n    };\n\n    const dataPack = Promise.all(userPoolDataPromises)\n    .then(values => {\n        const data = values.map((value, index) => {\n            const pending = ethers.utils.formatUnits(value, \"ether\");\n\n            const pool = poolInfo[index];\n            const lpToken = pool.lpToken;\n            const allocationPoints = ethers.utils.formatUnits(pool.allocPoint, \"wei\");\n            const accCobPerShare = ethers.utils.formatUnits(pool.accCobPerShare, \"ether\");\n            const depositFee = pool.depositFeeBP;\n            // const userApproved = fetchPoolAllowance() // fix this dummy\n            // pools, _signer, _account, _masterchef\n\n            return {\n                pendingReward: pending, \n                poolInformation: {\n                    depositTokenAddress: lpToken,\n                    allocation: allocationPoints,\n                    rewardPerShare: accCobPerShare,\n                    fee: depositFee\n                }};\n        })\n        return data;\n    })\n    return dataPack\n}\n\nexport const getPoolLength = async (_masterchef) => {\n    _masterchef.poolLength().then( res => {\n        return res\n    }); \n}\n\nexport const mapPendingToOriginalData = (newData, oldData, _masterchef, poolLength) => {\n    const staticPoolLength = oldData.length;\n    if (poolLength == staticPoolLength) {\n        const recycledData = newData.map((value, index) => {\n            const pending = value.pendingReward;\n            return {\n                pendingCob: pending,\n                ...oldData[index]\n            };\n        });\n\n        return recycledData;\n\n    } else {\n\n        console.log(`Devie needs to update static pool folder.  Your fetched pool length is ${poolLength} but your static pool length is ${staticPoolLength}`);\n        return oldData;\n\n    }\n\n\n}\n\nexport const getPoolBalance = async (poolData, _active, signer, account, abi, plength) => {\n\n\n    const balances = poolData.map( async (value, index) => {\n        const address = value.tokenStakeAddress\n        const erc20 =  await writeContract(_active, signer, account, address, abi)\n        const masterChefAddress = \"0xC71EbC899BCC111F39B2715B5d2D397E671B5bd2\"\n        const balance =  await erc20.balanceOf(masterChefAddress)\n        const stringbal = ethers.utils.formatUnits(balance, \"ether\")\n        return stringbal\n    });\n\n    const results = await Promise.all(balances)\n    return results\n}\n\n"]},"metadata":{},"sourceType":"module"}