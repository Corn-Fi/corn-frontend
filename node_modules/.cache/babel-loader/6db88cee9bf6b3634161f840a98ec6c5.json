{"ast":null,"code":"import React from \"react\";\nimport { ethers } from \"ethers\";\n\nconst getPoolInfo = async (_masterchef, poolLength) => {\n  const pLength = poolLength;\n  const poolInfo = [];\n\n  for (let index = 0; index < pLength; index++) {\n    const data = await _masterchef.poolInfo(index);\n    poolInfo.push(data);\n  }\n\n  return poolInfo;\n}; // works\n\n\nconst fetchUserPoolData = async (_masterChef, _library) => {\n  const signer = await fetchSigner();\n  const masterchefContract = await fetchContract(contractAddresses.masterChef, masterchef.abi, signer);\n  const pLength = await masterchefContract.poolLength();\n  const accountAddress = await _library.getAddress();\n  const poolInfo = await getPoolInfo();\n  const userPoolDataPromises = [];\n\n  for (let pid = 0; pid < pLength; pid++) {\n    const poolData = masterchefContract.pendingCob(pid, accountAddress);\n    userPoolDataPromises.push(poolData);\n  }\n\n  ;\n  const dataPack = Promise.all(userPoolDataPromises).then(values => {\n    const data = values.map((value, index) => {\n      const pending = ethers.utils.formatUnits(value, \"ether\");\n      const pool = poolInfo[index];\n      const lpToken = pool.lpToken;\n      const allocationPoints = ethers.utils.formatUnits(pool.allocPoint, \"wei\");\n      const accCobPerShare = ethers.utils.formatUnits(pool.accCobPerShare, \"ether\");\n      const depositFee = pool.depositFeeBP;\n      return {\n        pendingReward: pending,\n        poolInformation: {\n          depositTokenAddress: lpToken,\n          allocation: allocationPoints,\n          rewardPerShare: accCobPerShare,\n          fee: depositFee\n        }\n      };\n    });\n    return data;\n  });\n  return dataPack;\n};\n\nexport const getPoolLength = async _masterchef => {\n  _masterchef.poolLength().then(res => {\n    return res;\n  });\n};\nexport const mapPendingToOriginalData = (newData, oldData, _masterchef, poolLength) => {\n  const staticPoolLength = oldData.length;\n\n  if (poolLength == staticPoolLength) {\n    const recycledData = newData.map(value => {\n      const pending = value.pendingReward;\n      return {\n        pendingCob: pending,\n        ...oldData\n      };\n    });\n    return recycledData;\n  } else {\n    console.log(`Devie needs to update static pool folder.  Your fetched pool length is ${poolLength} but your static pool length is ${staticPoolLength}`);\n    return oldData;\n  }\n};","map":{"version":3,"sources":["/Users/nolanterry/Desktop/CORNLIMITFRONTEND/cornfrontend/src/utils/fetchUserData.js"],"names":["React","ethers","getPoolInfo","_masterchef","poolLength","pLength","poolInfo","index","data","push","fetchUserPoolData","_masterChef","_library","signer","fetchSigner","masterchefContract","fetchContract","contractAddresses","masterChef","masterchef","abi","accountAddress","getAddress","userPoolDataPromises","pid","poolData","pendingCob","dataPack","Promise","all","then","values","map","value","pending","utils","formatUnits","pool","lpToken","allocationPoints","allocPoint","accCobPerShare","depositFee","depositFeeBP","pendingReward","poolInformation","depositTokenAddress","allocation","rewardPerShare","fee","getPoolLength","res","mapPendingToOriginalData","newData","oldData","staticPoolLength","length","recycledData","console","log"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport {ethers} from \"ethers\";\n\nconst getPoolInfo = async (_masterchef, poolLength) => {\n    const pLength = poolLength\n\n    const poolInfo = [];\n    for (let index = 0; index < pLength; index++) {\n        const data = await _masterchef.poolInfo(index);\n        poolInfo.push(data);\n        \n    }\n\n    return poolInfo;\n} // works\n\nconst fetchUserPoolData = async (_masterChef, _library, ) => {\n\n    const signer = await fetchSigner();\n    const masterchefContract = await fetchContract(contractAddresses.masterChef, masterchef.abi, signer);\n    const pLength = await masterchefContract.poolLength();\n    const accountAddress = await _library.getAddress();\n    const poolInfo = await getPoolInfo();\n\n    const userPoolDataPromises = [];\n    for (let pid = 0; pid < pLength; pid++) {\n        const poolData = masterchefContract.pendingCob(pid, accountAddress);\n        userPoolDataPromises.push(poolData);\n    };\n\n    const dataPack = Promise.all(userPoolDataPromises)\n    .then(values => {\n        const data = values.map((value, index) => {\n            const pending = ethers.utils.formatUnits(value, \"ether\");\n\n            const pool = poolInfo[index];\n            const lpToken = pool.lpToken;\n            const allocationPoints = ethers.utils.formatUnits(pool.allocPoint, \"wei\");\n            const accCobPerShare = ethers.utils.formatUnits(pool.accCobPerShare, \"ether\");\n            const depositFee = pool.depositFeeBP;\n            \n\n            return {\n                pendingReward: pending, \n                poolInformation: {\n                    depositTokenAddress: lpToken,\n                    allocation: allocationPoints,\n                    rewardPerShare: accCobPerShare,\n                    fee: depositFee\n                }};\n        })\n        return data;\n    })\n    return dataPack\n}\n\nexport const getPoolLength = async (_masterchef) => {\n    _masterchef.poolLength().then( res => {\n        return res\n    }); \n}\n\nexport const mapPendingToOriginalData = (newData, oldData, _masterchef, poolLength) => {\n    const staticPoolLength = oldData.length;\n    if (poolLength == staticPoolLength) {\n\n        const recycledData = newData.map((value) => {\n            const pending = value.pendingReward;\n            return {\n                pendingCob: pending,\n                ...oldData\n            };\n        });\n\n        return recycledData;\n\n\n    } else {\n\n        console.log(`Devie needs to update static pool folder.  Your fetched pool length is ${poolLength} but your static pool length is ${staticPoolLength}`);\n        return oldData;\n\n    }\n\n\n}"]},"metadata":{},"sourceType":"module"}